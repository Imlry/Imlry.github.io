<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>zenxme</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://zenxme.github.io/"/>
  <updated>2020-03-13T13:23:15.157Z</updated>
  <id>https://zenxme.github.io/</id>
  
  <author>
    <name>zenxme</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>oh my zsh prompt修改</title>
    <link href="https://zenxme.github.io/2020/03/13/oh-my-zsh-prompt%E4%BF%AE%E6%94%B9/"/>
    <id>https://zenxme.github.io/2020/03/13/oh-my-zsh-prompt%E4%BF%AE%E6%94%B9/</id>
    <published>2020-03-13T13:10:13.000Z</published>
    <updated>2020-03-13T13:23:15.157Z</updated>
    
    <content type="html"><![CDATA[<p>对oh my zsh prompt样式的修改方法。</p><a id="more"></a><p>oh my zsh的主题默认在<code>~/.oh-my-zsh/themes/</code>下面，如果对某个主题的样式不满意的话可以对该主题文件进行编辑。</p><p>比如我用的这个robbyrussell主题，它默认只显示当前文件夹名，而不是整个路径，这有时候会让人分不清所在的具体路径，于是可以进行如下的命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">subl ~/.oh-my-zsh/themes/robbyrussell.zsh-theme</span><br></pre></td></tr></table></figure><p>其中，subl即sublime text的启动程序。</p><p>打开之后只需对其中的<code>PROMPT</code>变量进行修改即可。</p><p>可以看到原来<code>%{$fg[cyan]%}%c%{$reset_color%}</code>中的<code>%c</code>，它是当前文件夹名的意思，这里可以修改为<code>[$PWD]</code>，表示完整路径。这部分文本最终变成了<code>{$fg[cyan]%}[$PWD]%{$reset_color%}</code>。</p><p>接着我测试之后发现，如果某个完整太长的话会占据整个termianl的一行，新输入的命令往往有一部分要拐到下一行，很不方便观看。</p><p>于是我在搜索之后发现可以用<code>$&#39;\n&#39;</code>引用换行符来添加到<code>PROMPT</code>的末尾，最终修改结果如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">NEWLINE=$<span class="string">'\n'</span></span><br><span class="line">PRE_PROMPT=<span class="string">"%(?:%&#123;<span class="variable">$fg_bold</span>[green]%&#125;➜ :%&#123;<span class="variable">$fg_bold</span>[red]%&#125;➜ )"</span></span><br><span class="line">PROMPT=<span class="variable">$PRE_PROMPT</span></span><br><span class="line">PROMPT+=<span class="string">'%&#123;$fg[cyan]%&#125;[$PWD]%&#123;$reset_color%&#125; $(git_prompt_info)'</span></span><br><span class="line">PROMPT+=<span class="string">'$&#123;NEWLINE&#125;'</span></span><br><span class="line">PROMPT+=<span class="variable">$PRE_PROMPT</span></span><br></pre></td></tr></table></figure><p><img src="/2020/03/13/oh-my-zsh-prompt%E4%BF%AE%E6%94%B9/1.png" alt></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;对oh my zsh prompt样式的修改方法。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="oh my zsh" scheme="https://zenxme.github.io/tags/oh-my-zsh/"/>
    
  </entry>
  
  <entry>
    <title>Django ManyToManyField symmetrical 的原理</title>
    <link href="https://zenxme.github.io/2019/11/27/Django-ManyToManyField-symmetrical-%E7%9A%84%E5%8E%9F%E7%90%86/"/>
    <id>https://zenxme.github.io/2019/11/27/Django-ManyToManyField-symmetrical-%E7%9A%84%E5%8E%9F%E7%90%86/</id>
    <published>2019-11-26T21:43:54.000Z</published>
    <updated>2020-03-13T10:58:52.489Z</updated>
    
    <content type="html"><![CDATA[<p>对Django中ManyToManyField的symmetrical参数的实现进行分析。</p><a id="more"></a><p>首先来看官方文档 <a href="https://docs.djangoproject.com/en/2.2/ref/models/fields/#django.db.models.ManyToManyField.symmetrical" target="_blank" rel="noopener">ManyToManyField.symmetrical</a></p><blockquote><p>Only used in the definition of ManyToManyFields on self. Consider the following model:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">from</span> django.db <span class="keyword">import</span> models</span><br><span class="line"></span><br><span class="line">&gt;<span class="class"><span class="keyword">class</span> <span class="title">Person</span><span class="params">(models.Model)</span>:</span></span><br><span class="line">        friends = models.ManyToManyField(<span class="string">"self"</span>)</span><br></pre></td></tr></table></figure><p>When Django processes this model, it identifies that it has a ManyToManyField on itself, and as a result, it doesn’t add a person_set attribute to the Person class. Instead, the ManyToManyField is assumed to be symmetrical – that is, if I am your friend, then you are my friend.</p><p>If you do not want symmetry in many-to-many relationships with self, set symmetrical to False. This will force Django to add the descriptor for the reverse relationship, allowing ManyToManyField relationships to be non-symmetrical.</p></blockquote><p>symmetrical字面意思为对称，文档里也说了，这个参数仅仅在ManyToManyFields指向self的时候有用。</p><p>而举的例子也很简单明了，如果我是你的朋友，那么你也是我的朋友，这是默认的情况。如果不想用这种默认情况，那么就需要手动把它设置为False。</p><p>那么这种默认情况下，django到底是怎么实现的？首先一个中间表应该是必须的。</p><p>另外我猜到可能有2种实现：</p><ul><li>每次都存储2份数据，比如存一列用户a是b的朋友，再存一列b是a的朋友</li><li>每次只存1份，把用户id较小的放到第一列。</li></ul><p>下面写代码看下数据库是怎么存的：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.contrib.auth.models <span class="keyword">import</span> AbstractUser</span><br><span class="line"><span class="keyword">from</span> django.db <span class="keyword">import</span> models</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span><span class="params">(AbstractUser)</span>:</span></span><br><span class="line">    friends = models.ManyToManyField(<span class="string">"self"</span>)</span><br></pre></td></tr></table></figure><p>使用<code>python manage.py shell</code> 进入django的shell</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> user.models <span class="keyword">import</span> User</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>foo = User()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>foo.username = <span class="string">'foo'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>foo.set_password(<span class="string">'123'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>foo.save()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>bar = User()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>bar.username = <span class="string">'bar'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>bar.set_password(<span class="string">'123'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>bar.save()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>foo.friends.add(bar)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>foo.friends.all()</span><br><span class="line">&lt;QuerySet [&lt;User: bar&gt;]&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>bar.friends.all()</span><br><span class="line">&lt;QuerySet [&lt;User: foo&gt;]&gt;</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>tom = User()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>tom.username = <span class="string">'tom'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>tom.set_password(<span class="number">123</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>tom.save()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>tom.friends.add(foo)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>foo.friends.all()</span><br><span class="line">&lt;QuerySet [&lt;User: bar&gt;, &lt;User: tom&gt;]&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">SQLite version 3.22.0 2018-01-22 18:45:57</span><br><span class="line">Enter &quot;.help&quot; for usage hints.</span><br><span class="line">sqlite&gt; .tables</span><br><span class="line">auth_group                  django_session            </span><br><span class="line">auth_group_permissions      user_user                 </span><br><span class="line">auth_permission             user_user_friends         </span><br><span class="line">django_admin_log            user_user_groups          </span><br><span class="line">django_content_type         user_user_user_permissions</span><br><span class="line">django_migrations</span><br><span class="line"></span><br><span class="line">sqlite&gt; .schema user_user_friends</span><br><span class="line">CREATE TABLE IF NOT EXISTS &quot;user_user_friends&quot; (&quot;id&quot; integer NOT NULL PRIMARY KEY AUTOINCREMENT, &quot;from_user_id&quot; integer NOT NULL REFERENCES &quot;user_user&quot; (&quot;id&quot;) DEFERRABLE INITIALLY DEFERRED, &quot;to_user_id&quot; integer NOT NULL REFERENCES &quot;user_user&quot; (&quot;id&quot;) DEFERRABLE INITIALLY DEFERRED);</span><br><span class="line">CREATE UNIQUE INDEX &quot;user_user_friends_from_user_id_to_user_id_1f3f3c7e_uniq&quot; ON &quot;user_user_friends&quot; (&quot;from_user_id&quot;, &quot;to_user_id&quot;);</span><br><span class="line">CREATE INDEX &quot;user_user_friends_from_user_id_317b081e&quot; ON &quot;user_user_friends&quot; (&quot;from_user_id&quot;);</span><br><span class="line">CREATE INDEX &quot;user_user_friends_to_user_id_c77c2cf7&quot; ON &quot;user_user_friends&quot; (&quot;to_user_id&quot;);</span><br><span class="line"></span><br><span class="line">sqlite&gt; .header on</span><br><span class="line"></span><br><span class="line">sqlite&gt; select * from user_user_friends;</span><br><span class="line">id|from_user_id|to_user_id</span><br><span class="line">1|1|2</span><br><span class="line">2|2|1</span><br><span class="line">3|3|1</span><br><span class="line">4|1|3</span><br></pre></td></tr></table></figure><p>可以看到django生成了一个名字叫user_user_friends的中间表，而且从建表语句可以看到有3个id列，分别是1个自增主键和2个外键。</p><p>查看数据可以发现是之前的第一种猜想。</p><p>在调用<code>foo.friends.add(bar)</code>的时候，插入了两行数据<code>(1, 2)</code>和<code>(2, 1)</code>。</p><p>在调用<code>tom.friends.add(foo)</code>的时候，插入了两行数据<code>(3, 1)</code>和<code>(1, 3)</code>。</p><p>每次先插入的行都是调用者的id在前。</p><p>在经过了一段时间的查找之后，在django的源码里也找到了相关的代码，印证了之前的看法。</p><p><code>django/db/models/fields/related_descriptors.py</code>里<code>ManyRelatedManager</code>类的部分代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(self, *objs, through_defaults=None)</span>:</span></span><br><span class="line">    self._remove_prefetched_objects()</span><br><span class="line">    db = router.db_for_write(self.through, instance=self.instance)</span><br><span class="line">    <span class="keyword">with</span> transaction.atomic(using=db, savepoint=<span class="literal">False</span>):</span><br><span class="line">        self._add_items(</span><br><span class="line">            self.source_field_name, self.target_field_name, *objs,</span><br><span class="line">            through_defaults=through_defaults,</span><br><span class="line">        )</span><br><span class="line">        <span class="comment"># If this is a symmetrical m2m relation to self, add the mirror</span></span><br><span class="line">        <span class="comment"># entry in the m2m table. `through_defaults` aren't used here</span></span><br><span class="line">        <span class="comment"># because of the system check error fields.E332: Many-to-many</span></span><br><span class="line">        <span class="comment"># fields with intermediate tables must not be symmetrical.</span></span><br><span class="line">        <span class="keyword">if</span> self.symmetrical:</span><br><span class="line">            self._add_items(self.target_field_name, self.source_field_name, *objs)</span><br></pre></td></tr></table></figure><p>可以看到是在一个事务里面进行的，调用了两次<code>self._add_items</code>，第一次是<code>source_field_name</code>在前，第二次是<code>target_field_name</code>在前。</p><p>django默认的这种行为虽然也不错，但是会占用2倍的空间，如果用户量越来越大的时候劣势会更明显。但是暂时还不太清楚django默认这种机制的道理。</p><p>在目前的我看来，更倾向于第二种想法，就是在插入之前先判断id的大小，每次都使得小的id在前，这样可以节省空间。所以我一般都会把symmetrical设为False。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;对Django中ManyToManyField的symmetrical参数的实现进行分析。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="python" scheme="https://zenxme.github.io/tags/python/"/>
    
      <category term="django" scheme="https://zenxme.github.io/tags/django/"/>
    
  </entry>
  
  <entry>
    <title>Django Rest framework 在自定义serializer的Field的时候无法传递None</title>
    <link href="https://zenxme.github.io/2019/11/02/Django-Rest-framework-%E5%9C%A8%E8%87%AA%E5%AE%9A%E4%B9%89serializer%E7%9A%84Field%E7%9A%84%E6%97%B6%E5%80%99%E6%97%A0%E6%B3%95%E4%BC%A0%E9%80%92None/"/>
    <id>https://zenxme.github.io/2019/11/02/Django-Rest-framework-%E5%9C%A8%E8%87%AA%E5%AE%9A%E4%B9%89serializer%E7%9A%84Field%E7%9A%84%E6%97%B6%E5%80%99%E6%97%A0%E6%B3%95%E4%BC%A0%E9%80%92None/</id>
    <published>2019-11-02T03:58:15.000Z</published>
    <updated>2020-03-11T06:43:10.351Z</updated>
    
    <content type="html"><![CDATA[<p>在使用Django Rest framework框架的时候遇到的一个问题</p><a id="more"></a><p>有一个<code>UserSerializer</code>的类，我想当没有默认的<code>avatar_url</code>的时候返回一个默认的<code>url</code>地址，于是写了这样的一个<code>Field</code>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserAvatarField</span><span class="params">(serializers.CharField)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">to_representation</span><span class="params">(self, value)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> value:</span><br><span class="line">            <span class="keyword">return</span> super().to_representation(value)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> get_default_user_avatar_url()</span><br></pre></td></tr></table></figure><p>然后在定义serializer的时候这么用：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserSerializer</span><span class="params">(serializers.ModelSerializer)</span>:</span></span><br><span class="line">    avatar_url = UserAvatarField(max_length=<span class="number">255</span>)</span><br><span class="line">    <span class="comment"># ......</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Meta</span>:</span></span><br><span class="line">        model = User</span><br><span class="line">        <span class="comment"># ......</span></span><br></pre></td></tr></table></figure><p>结果发现，当<code>User</code>实例的<code>avatar_url</code>属性有数据的时候可以正常返回数据，但是当它为<code>None</code>的时候，就不会进入<code>Field</code>的<code>to_represtation</code>方法，于是去查看了下父类的源码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">to_representation</span><span class="params">(self, instance)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    Object instance -&gt; Dict of primitive datatypes.</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    ret = OrderedDict()</span><br><span class="line">    fields = self._readable_fields</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> field <span class="keyword">in</span> fields:</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            attribute = field.get_attribute(instance)</span><br><span class="line">        <span class="keyword">except</span> SkipField:</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># We skip `to_representation` for `None` values so that fields do</span></span><br><span class="line">        <span class="comment"># not have to explicitly deal with that case.</span></span><br><span class="line">        <span class="comment">#</span></span><br><span class="line">        <span class="comment"># For related fields with `use_pk_only_optimization` we need to</span></span><br><span class="line">        <span class="comment"># resolve the pk value.</span></span><br><span class="line">        check_for_none = attribute.pk <span class="keyword">if</span> isinstance(attribute, PKOnlyObject) <span class="keyword">else</span> attribute</span><br><span class="line">        <span class="keyword">if</span> check_for_none <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            ret[field.field_name] = <span class="literal">None</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            ret[field.field_name] = field.to_representation(attribute)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ret</span><br></pre></td></tr></table></figure><p>通过这句注释<code>We skip  to_representation for  None values so that fields do not have to explicitly deal with that case.</code>以及下面的代码可以很容易看出来，如果为<code>None</code>的时候就不会传递给<code>feild</code>的<code>to_representation</code>方法。</p><p>我觉得这个设计很不合理，因为当为<code>None</code>的时候，这个<code>field</code>根本不会收到这个value，这样即使它想要采取其它的动作，或者返回其它的值，都是不可能的。</p><p>但是没有办法，我只能采取另一种方法，重写<code>serializer</code>的<code>to_representation</code>方法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">to_representation</span><span class="params">(self, instance)</span>:</span></span><br><span class="line">    ret = super().to_representation(instance)</span><br><span class="line">    <span class="keyword">if</span> ret.get(<span class="string">"avatar_url"</span>):</span><br><span class="line">        <span class="keyword">return</span> ret</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        ret[<span class="string">"avatar_url"</span>] = get_default_user_avatar_url()</span><br><span class="line">        <span class="keyword">return</span> ret</span><br></pre></td></tr></table></figure><p>而且把之前<code>avatar_url</code>字段的定义删掉就行了，因为这里继承的是<code>ModelSerializer</code>，如果不改用自定义的字段的话它会默认生成一个和数据库的<code>field</code>对应的字段。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在使用Django Rest framework框架的时候遇到的一个问题&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="python" scheme="https://zenxme.github.io/tags/python/"/>
    
      <category term="django" scheme="https://zenxme.github.io/tags/django/"/>
    
  </entry>
  
  <entry>
    <title>解决ubuntu 18.04下guake3.0.5输入exit会导致tab卡死的问题</title>
    <link href="https://zenxme.github.io/2019/06/13/%E8%A7%A3%E5%86%B3ubuntu-18-04%E4%B8%8Bguake3-0-5%E8%BE%93%E5%85%A5exit%E4%BC%9A%E5%AF%BC%E8%87%B4tab%E5%8D%A1%E6%AD%BB%E7%9A%84%E9%97%AE%E9%A2%98/"/>
    <id>https://zenxme.github.io/2019/06/13/%E8%A7%A3%E5%86%B3ubuntu-18-04%E4%B8%8Bguake3-0-5%E8%BE%93%E5%85%A5exit%E4%BC%9A%E5%AF%BC%E8%87%B4tab%E5%8D%A1%E6%AD%BB%E7%9A%84%E9%97%AE%E9%A2%98/</id>
    <published>2019-06-12T20:01:59.000Z</published>
    <updated>2020-03-11T06:43:10.356Z</updated>
    
    <content type="html"><![CDATA[<p>在我转到ubuntu16转到18的时候，遇到的guake的一个bug。</p><a id="more"></a><p>具体表现就是，在输入<code>exit</code>退出某个tab的时候，会导致这个tab卡死。</p><p>在google了一番之后，得到了2种解决方法，这两种方法都可以解决。</p><ol><li>执行<code>sudo apt install --reinstall libutempter0</code></li><li>按照这个<a href="https://github.com/Guake/guake/commit/f8699b4be6c058fd58a33a1d783cd404e9076b0e" target="_blank" rel="noopener">commit</a>的做法，找到guake的目录，把<code>guake.app</code>种1435行向左移动4个空格即可。</li></ol><p>参考链接：</p><ul><li><a href="https://bugs.launchpad.net/ubuntu/+source/guake/+bug/1760621" target="_blank" rel="noopener">https://bugs.launchpad.net/ubuntu/+source/guake/+bug/1760621</a></li><li><a href="https://github.com/Guake/guake/issues/1198" target="_blank" rel="noopener">https://github.com/Guake/guake/issues/1198</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在我转到ubuntu16转到18的时候，遇到的guake的一个bug。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="ubuntu" scheme="https://zenxme.github.io/tags/ubuntu/"/>
    
      <category term="bug" scheme="https://zenxme.github.io/tags/bug/"/>
    
  </entry>
  
  <entry>
    <title>关于python的GIL</title>
    <link href="https://zenxme.github.io/2019/04/30/%E5%85%B3%E4%BA%8Epython%E7%9A%84GIL/"/>
    <id>https://zenxme.github.io/2019/04/30/%E5%85%B3%E4%BA%8Epython%E7%9A%84GIL/</id>
    <published>2019-04-30T09:28:24.000Z</published>
    <updated>2020-03-11T06:43:10.355Z</updated>
    
    <content type="html"><![CDATA[<p>对GIL(全局解释器锁)的理解。</p><a id="more"></a><h2 id="什么是GIL"><a href="#什么是GIL" class="headerlink" title="什么是GIL"></a>什么是GIL</h2><p>官方的<a href="https://wiki.python.org/moin/GlobalInterpreterLock" target="_blank" rel="noopener">wiki</a>中是这么说的：</p><blockquote><p>In CPython, the global interpreter lock, or GIL, is a mutex that protects access to Python objects, preventing multiple threads from executing Python bytecodes at once. This lock is necessary mainly because CPython’s memory management is not thread-safe. (However, since the GIL exists, other features have grown to depend on the guarantees that it enforces.)</p></blockquote><p>CPython，是官方的、用C语言写的python解释器，也是最被广泛使用的解释器。</p><p>GIL是全局解释器锁，为了避免多线程同时执行python字节码。这个锁之所以必要，是因为CPython的内存管理不是线程安全的。</p><p>所以我的题目也是有点问题的，不是Python的GIL，而是CPython的GIL。Python是一种语言，而CPython是对这个语言实现的一个解释器。除了CPython之外，还有很多Python的解释器，比如Jython、IronPython、PyPy等等。</p><h2 id="GIL的缺点"><a href="#GIL的缺点" class="headerlink" title="GIL的缺点"></a>GIL的缺点</h2><p>当时，Python的创造者Guido van Rossum在写Python的时候，多核的机器还不常见，使用一个全局的锁设计起来比较简单。但是随着硬件的发展，现在已经是多核处理器的天下了。而CPython还是只能使用一个处理器核心，这样很明显会无法充分利用计算机的性能。若只是I/O密集型任务，那么多线程还是可以提高处理效率的。然而对CPU密集型任务，非但无法提高处理速度，甚至会降低速度（由于线程的切换）。</p><h2 id="能否去除GIL"><a href="#能否去除GIL" class="headerlink" title="能否去除GIL"></a>能否去除GIL</h2><p>由于多年的积累，CPython已经积累了大量的标准库和第三方库，它们都是在依赖GIL的情况下开发的。</p><p>虽然其它的Python解释器去除了GIL，但是可用的第三方库却很少。</p><p>直接在CPython上去掉GIL，而不影响现存的其它库是非常困难的。比如Guido的这篇博客：<a href="https://www.artima.com/weblogs/viewpost.jsp?thread=214235" target="_blank" rel="noopener">It isn’t Easy to Remove the GIL</a>。在文中他提到之前有人实现了去掉GIL、换成细粒度的锁的版本，但是那样使得单线程的运行速度减慢了2倍。文章的最后，Guido写到：</p><blockquote><p>I want to point out one more time that the <em>language</em> doesn’t require the GIL – it’s only the CPython virtual machine that has historically been unable to shed it.</p></blockquote><p>再次强调了，不是Python语言需要GIL，而是CPython的历史原因无法去除GIL。</p><h2 id="如何提升速度"><a href="#如何提升速度" class="headerlink" title="如何提升速度"></a>如何提升速度</h2><ul><li>对I/O密集型任务：多线程、协程</li><li>对CPU密集型任务：多进程、C语言扩展</li><li>使用其它解释器（但这种情况可能缺少第三方库，或是缺少Python语言的某些特性）</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;对GIL(全局解释器锁)的理解。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="python" scheme="https://zenxme.github.io/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>scrapy中的数据流</title>
    <link href="https://zenxme.github.io/2019/04/28/scrapy%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E6%B5%81/"/>
    <id>https://zenxme.github.io/2019/04/28/scrapy%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E6%B5%81/</id>
    <published>2019-04-28T09:22:26.000Z</published>
    <updated>2020-03-11T06:43:10.353Z</updated>
    
    <content type="html"><![CDATA[<p>Python爬虫框架scrapy的整个数据流。</p><a id="more"></a><h2 id="数据流"><a href="#数据流" class="headerlink" title="数据流"></a>数据流</h2><p><img src="/2019/04/28/scrapy%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E6%B5%81/scrapy_architecture.png" alt></p><p>整个架构以Engine为中心，控制数据流在系统中的流动。</p><ol><li>Request从用户编写的Spider发出，经过SpiderMiddleware到达Engine。</li><li>Engine将Request交给Scheduler，Scheduler把Request入队。</li><li>Scheduler从队列中取出Request交给Engine。</li><li>Request经DownloaderMiddleware到达Downloader，Downloader从互联网上下载数据，结束之后产生一个Response。</li><li>Downloader把Response经过DownloaderMIddleware发往Engine。</li><li>Engine把Response经过SpiderMiddleware交给Spider。</li><li>Spider可以产生Item或者Request，它们都会经过SpiderMiddleware到达Engine。</li><li>Engine把Request重复从2开始的步骤，把Item交给ItemPipeline进行处理。</li></ol><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://docs.scrapy.org/en/latest/topics/architecture.html" target="_blank" rel="noopener">官方文档</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Python爬虫框架scrapy的整个数据流。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="python" scheme="https://zenxme.github.io/tags/python/"/>
    
      <category term="爬虫" scheme="https://zenxme.github.io/tags/%E7%88%AC%E8%99%AB/"/>
    
  </entry>
  
  <entry>
    <title>Python线程池和进程池</title>
    <link href="https://zenxme.github.io/2019/04/11/Python%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%92%8C%E8%BF%9B%E7%A8%8B%E6%B1%A0/"/>
    <id>https://zenxme.github.io/2019/04/11/Python%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%92%8C%E8%BF%9B%E7%A8%8B%E6%B1%A0/</id>
    <published>2019-04-11T08:15:36.000Z</published>
    <updated>2020-03-11T06:43:10.352Z</updated>
    
    <content type="html"><![CDATA[<p>Python3.2之后，标准库里引入了<code>concurrent.futures</code>模块，为异步调用提供了高级的接口。在此记录下我对其中的<code>ThreadPoolExecutor</code>和<code>ProcessPoolExecutor</code>类的学习和理解。</p><a id="more"></a><h2 id="ThreadPoolExecutor"><a href="#ThreadPoolExecutor" class="headerlink" title="ThreadPoolExecutor"></a>ThreadPoolExecutor</h2><p><code>ThreadPoolExecutor</code>是<code>Executor</code>类的子类。它有一个参数是<code>max_workers</code>，指定了线程池中最多同时执行的线程数量。这个是最常用的参数，3.5版本之后又增加了几个参数，但是不常用，可以去文档里查看。</p><h3 id="1个线程"><a href="#1个线程" class="headerlink" title="1个线程"></a>1个线程</h3><p>开启1个线程访问<code>https://www.baidu.com/</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> concurrent.futures <span class="keyword">import</span> ThreadPoolExecutor</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_headers</span><span class="params">(url)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> (url, requests.get(url).headers)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> ThreadPoolExecutor(<span class="number">1</span>) <span class="keyword">as</span> executor:</span><br><span class="line">    f = executor.submit(get_headers, <span class="string">'https://www.baidu.com/'</span>)</span><br><span class="line">    print(f.result())</span><br></pre></td></tr></table></figure><h3 id="3个线程"><a href="#3个线程" class="headerlink" title="3个线程"></a>3个线程</h3><p>开启3个线程分别访问<code>https://www.baidu.com/</code>、<code>https://www.163.com/</code>、<code>https://www.qq.com/</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> concurrent.futures <span class="keyword">import</span> ThreadPoolExecutor, as_completed</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_headers</span><span class="params">(url)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> (url, requests.get(url).headers)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> ThreadPoolExecutor(<span class="number">3</span>) <span class="keyword">as</span> executor:</span><br><span class="line">    fs = [</span><br><span class="line">        executor.submit(get_headers, <span class="string">'https://www.baidu.com/'</span>),</span><br><span class="line">        executor.submit(get_headers, <span class="string">'https://www.163.com/'</span>),</span><br><span class="line">        executor.submit(get_headers, <span class="string">'https://www.qq.com/'</span>),</span><br><span class="line">    ]</span><br><span class="line">    <span class="keyword">for</span> f <span class="keyword">in</span> as_completed(fs):</span><br><span class="line">        print(f.result())</span><br></pre></td></tr></table></figure><p>也可以使用<code>map</code>函数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> concurrent.futures <span class="keyword">import</span> ThreadPoolExecutor</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_headers</span><span class="params">(url)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> (url, requests.get(url).headers)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> ThreadPoolExecutor(<span class="number">3</span>) <span class="keyword">as</span> executor:</span><br><span class="line">    urls = [</span><br><span class="line">        <span class="string">'https://www.baidu.com/'</span>,</span><br><span class="line">        <span class="string">'https://www.163.com/'</span>,</span><br><span class="line">        <span class="string">'https://www.qq.com/'</span>,</span><br><span class="line">    ]</span><br><span class="line">    <span class="keyword">for</span> result <span class="keyword">in</span> executor.map(get_headers, urls):</span><br><span class="line">        print(result)</span><br></pre></td></tr></table></figure><p>需要注意的是，使用<code>map</code>函数时，返回的结果的顺序和Python内置的map函数一样，是按照传递进去的顺序来的，并不是真正的它们完成的顺序。比如在上面的代码里，第一个返回的永远是baidu的请求。通过查看源码也印证了这一问题。</p><p><code>Executor.map</code>的源码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">map</span><span class="params">(self, fn, *iterables, timeout=None, chunksize=<span class="number">1</span>)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> timeout <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">        end_time = timeout + time.monotonic()</span><br><span class="line"></span><br><span class="line">    fs = [self.submit(fn, *args) <span class="keyword">for</span> args <span class="keyword">in</span> zip(*iterables)]</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Yield must be hidden in closure so that the futures are submitted</span></span><br><span class="line">    <span class="comment"># before the first iterator value is required.</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">result_iterator</span><span class="params">()</span>:</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="comment"># reverse to keep finishing order</span></span><br><span class="line">            fs.reverse()</span><br><span class="line">            <span class="keyword">while</span> fs:</span><br><span class="line">                <span class="comment"># Careful not to keep a reference to the popped future</span></span><br><span class="line">                <span class="keyword">if</span> timeout <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">                    <span class="keyword">yield</span> fs.pop().result()</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">yield</span> fs.pop().result(end_time - time.monotonic())</span><br><span class="line">        <span class="keyword">finally</span>:</span><br><span class="line">            <span class="keyword">for</span> future <span class="keyword">in</span> fs:</span><br><span class="line">                future.cancel()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result_iterator()</span><br></pre></td></tr></table></figure><p>先调用<code>fs.reverse</code>转置列表，然后不断调用pop取最后一个的result。</p><h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> concurrent.futures <span class="keyword">import</span> ThreadPoolExecutor</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">a_work</span><span class="params">()</span>:</span></span><br><span class="line">    time.sleep(<span class="number">5</span>)</span><br><span class="line">    print(b.result())</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'a'</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">b_work</span><span class="params">()</span>:</span></span><br><span class="line">    time.sleep(<span class="number">5</span>)</span><br><span class="line">    print(a.result())</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'b'</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> ThreadPoolExecutor(<span class="number">2</span>) <span class="keyword">as</span> executor:</span><br><span class="line">    a = executor.submit(a_work)</span><br><span class="line">    b = executor.submit(b_work)</span><br></pre></td></tr></table></figure><p>这个程序永远都不会运行结束，因为线程a在等待b的结果，b在等待a的结果。其中的<code>time.sleep(5)</code>非常关键，它可以保证这两个线程都开始运行了。</p><p>去掉它之后，可以发现程序居然可以运行结束了，但是却没有任何的输出。这其实就是第二个常见错误，只有调用在<code>future</code>对象上调用<code>result()</code>函数之后，异常才可以被捕获。</p><h3 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> concurrent.futures <span class="keyword">import</span> ThreadPoolExecutor</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">a_work</span><span class="params">()</span>:</span></span><br><span class="line">    print(after_b)</span><br><span class="line">    print(b.result())</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'a'</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">b_work</span><span class="params">()</span>:</span></span><br><span class="line">    print(a.result())</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'b'</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">after_b = <span class="literal">False</span></span><br><span class="line"><span class="keyword">with</span> ThreadPoolExecutor(<span class="number">2</span>) <span class="keyword">as</span> executor:</span><br><span class="line">    a = executor.submit(a_work)</span><br><span class="line">    b = executor.submit(b_work)</span><br><span class="line">    after_b = <span class="literal">True</span></span><br><span class="line">    print(a.result(), b.result())</span><br></pre></td></tr></table></figure><p>运行上面的代码，可以发现程序输出了一个<code>False</code>，和一个异常：<code>NameError: name &#39;b&#39; is not defined</code>，这是因为a线程已经开始运行了，但是b还没有开始，即，submit函数还没有返回，那么这个时候after_b的值仍然是False，而且变量b还是未定义的。</p><p>我们之前的代码，之所以没有出现异常，就是因为没有调用result函数。下面的代码可以更直观的说明问题。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> concurrent.futures <span class="keyword">import</span> ThreadPoolExecutor</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">raise_exception</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">raise</span> ValueError(<span class="string">'123'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> ThreadPoolExecutor(<span class="number">1</span>) <span class="keyword">as</span> executor:</span><br><span class="line">    a = executor.submit(raise_exception)</span><br><span class="line">    <span class="comment"># a.result()</span></span><br></pre></td></tr></table></figure><p>运行这段代码，不会有任何输出。把<code>a.result()</code>这一行的注释取消，就可以看到异常：<code>ValueError: 123</code>。</p><h2 id="ProcessPoolExecutor"><a href="#ProcessPoolExecutor" class="headerlink" title="ProcessPoolExecutor"></a>ProcessPoolExecutor</h2><p>和<code>ThreadPoolExecutor</code>的用法基本上类似，不同之处在于，只有可以被pickle库序列化的对象才可以被执行和返回。因为需要在不同的进程之间传递消息。这个类使用了multiprocessing库。</p><h2 id="为什么要使用进程池和线程池？"><a href="#为什么要使用进程池和线程池？" class="headerlink" title="为什么要使用进程池和线程池？"></a>为什么要使用进程池和线程池？</h2><p>在我的理解看来，线程和进程的创建是需要开销的，而之前创建的线程或进程在执行完了任务之后，可以先不销毁，继续用来执行以后的任务。还有一个优势就是方便对这些创建的进程和线程进行统一的管理。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>官方文档：<a href="https://docs.python.org/3/library/concurrent.futures.html" target="_blank" rel="noopener">https://docs.python.org/3/library/concurrent.futures.html</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Python3.2之后，标准库里引入了&lt;code&gt;concurrent.futures&lt;/code&gt;模块，为异步调用提供了高级的接口。在此记录下我对其中的&lt;code&gt;ThreadPoolExecutor&lt;/code&gt;和&lt;code&gt;ProcessPoolExecutor&lt;/code&gt;类的学习和理解。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="python" scheme="https://zenxme.github.io/tags/python/"/>
    
      <category term="线程" scheme="https://zenxme.github.io/tags/%E7%BA%BF%E7%A8%8B/"/>
    
      <category term="进程" scheme="https://zenxme.github.io/tags/%E8%BF%9B%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>dgraph数据库简单总结</title>
    <link href="https://zenxme.github.io/2019/04/09/dgraph%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AE%80%E5%8D%95%E6%80%BB%E7%BB%93/"/>
    <id>https://zenxme.github.io/2019/04/09/dgraph%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AE%80%E5%8D%95%E6%80%BB%E7%BB%93/</id>
    <published>2019-04-09T03:37:09.000Z</published>
    <updated>2020-03-11T06:43:10.352Z</updated>
    
    <content type="html"><![CDATA[<p>对可扩展的，分布式的，低延迟图形数据库dgraph的用法的简单总结。</p><a id="more"></a><h2 id="安装dgraph"><a href="#安装dgraph" class="headerlink" title="安装dgraph"></a>安装dgraph</h2><p>在linux系统上，可以这样安装：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl https://get.dgraph.io -sSf | bash</span><br></pre></td></tr></table></figure><p>如果要使用docker或者从其他系统上，可以参考 <a href="https://docs.dgraph.io/get-started/#step-1-install-dgraph" target="_blank" rel="noopener">https://docs.dgraph.io/get-started/#step-1-install-dgraph</a></p><h2 id="启动dgraph"><a href="#启动dgraph" class="headerlink" title="启动dgraph"></a>启动dgraph</h2><p>开3个terminal，依次启动下面的3个程序</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dgraph zero</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dgraph alpha --lru_mb 2048 --zero localhost:5080</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dgraph-ratel</span><br></pre></td></tr></table></figure><p>之后，访问<code>http://localhost:8000/</code>就可以看到一个图形化的界面。</p><h2 id="端口的使用"><a href="#端口的使用" class="headerlink" title="端口的使用"></a>端口的使用</h2><table><thead><tr><th align="left">Dgraph Node Type</th><th align="left">gRPC-internal</th><th align="left">gRPC-external</th><th align="left">HTTP-external</th></tr></thead><tbody><tr><td align="left">zero</td><td align="left">–Not Used–</td><td align="left">5080</td><td align="left">6080</td></tr><tr><td align="left">alpha</td><td align="left">7080</td><td align="left">9080</td><td align="left">8080</td></tr><tr><td align="left">ratel</td><td align="left">–Not Used–</td><td align="left">–Not Used–</td><td align="left">8000</td></tr></tbody></table><h2 id="加载数据"><a href="#加载数据" class="headerlink" title="加载数据"></a>加载数据</h2><p>若要在运行中实时加载数据和schema文件，可以使用如下的命令。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dgraph live -r g01.rdf.gz -s g01.schema -d localhost:9080 -z localhost:5080</span><br></pre></td></tr></table></figure><p>详见：<a href="https://docs.dgraph.io/deploy/#fast-data-loading" target="_blank" rel="noopener">https://docs.dgraph.io/deploy/#fast-data-loading</a></p><h2 id="插入和查询数据"><a href="#插入和查询数据" class="headerlink" title="插入和查询数据"></a>插入和查询数据</h2><p>有很多官方的和非官方的客户端，甚至可以使用HTTP请求来做到。</p><p>详见：<a href="https://docs.dgraph.io/clients/" target="_blank" rel="noopener">https://docs.dgraph.io/clients/</a></p><h2 id="导出数据"><a href="#导出数据" class="headerlink" title="导出数据"></a>导出数据</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl localhost:8080/admin/<span class="built_in">export</span></span><br></pre></td></tr></table></figure><p>在服务器本地，向<code>localhost:8080/admin/export</code>发出<code>GET</code>请求就行了，可以导出到<code>~/export</code>文件夹下。</p><p>其它的用法，都可以查阅官方文档：<a href="https://docs.dgraph.io/" target="_blank" rel="noopener">https://docs.dgraph.io/</a>。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;对可扩展的，分布式的，低延迟图形数据库dgraph的用法的简单总结。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="数据库" scheme="https://zenxme.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="dgraph" scheme="https://zenxme.github.io/tags/dgraph/"/>
    
  </entry>
  
  <entry>
    <title>MySQL优化方法总结</title>
    <link href="https://zenxme.github.io/2019/03/30/MySQL%E4%BC%98%E5%8C%96%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93/"/>
    <id>https://zenxme.github.io/2019/03/30/MySQL%E4%BC%98%E5%8C%96%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93/</id>
    <published>2019-03-30T06:42:16.000Z</published>
    <updated>2020-03-11T06:43:10.351Z</updated>
    
    <content type="html"><![CDATA[<p>对MySQL的各种优化方法的总结。</p><a id="more"></a><h2 id="如何找出运行速度慢的语句"><a href="#如何找出运行速度慢的语句" class="headerlink" title="如何找出运行速度慢的语句"></a>如何找出运行速度慢的语句</h2><ul><li>开启慢查询日志（Slow Query Log），找出查询效率低的语句。（通过改变long_query_time的值来控制时间，超出这个值的语句就会被记录）</li></ul><h2 id="分析查询语句"><a href="#分析查询语句" class="headerlink" title="分析查询语句"></a>分析查询语句</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">EXPLAIN</span> [<span class="keyword">EXTENDED</span>] <span class="keyword">SELECT</span> select_options</span><br></pre></td></tr></table></figure><p><code>EXTENDED</code>是可选的，加上之后将产生更多的信息。<code>select_options</code>代表剩下的SELECT语句的查询选项。</p><p>也可以使用<code>DESCRIBE</code>，或者也可以使用它的简写<code>DESC</code></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DESCRIBE</span> <span class="keyword">SELECT</span> select_options</span><br></pre></td></tr></table></figure><h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><p>建立索引可以显著地提高查询的速度，但并不是所有的查询情况下索引都会起作用，下面是一些特殊情况。</p><ol><li>使用<code>LIKE</code>关键字的查询语句，如果第一个字符为<code>%</code>，索引不会起作用。</li><li>使用多列索引的查询语句，如果查询条件不包含第一个字段，索引不会起作用。</li><li>查询语句的条件只有<code>OR</code>关键字，并且<code>OR</code>前后的两个条件中的列都是索引时，查询中才使用索引。否则，查询将不使用索引。</li></ol><h2 id="优化子查询"><a href="#优化子查询" class="headerlink" title="优化子查询"></a>优化子查询</h2><p>子查询虽然很灵活，但是效率不高，MySQL需要为内层语句的查询结果建立一个临时表，查询完毕后再撤销这些临时表。</p><p>可以使用连接（JOIN）来代替子查询，这样就省去了建立和撤销临时表的开销，加快了速度。</p><h2 id="优化数据库结构"><a href="#优化数据库结构" class="headerlink" title="优化数据库结构"></a>优化数据库结构</h2><ol><li>对字段较多的表，可以把其中使用频率低的一部分字段分离出来建立一个新的表。</li><li>对经常需要联合查询的表，可以建立中间表，把需要经常联合查询的数据插入到中间表中，然后把原来的联合查询改为对中间表的查询。</li><li>适当地增加冗余字段。(但是可能会产生数据不一致问题)</li></ol><h2 id="优化插入"><a href="#优化插入" class="headerlink" title="优化插入"></a>优化插入</h2><h3 id="对MyISAM表"><a href="#对MyISAM表" class="headerlink" title="对MyISAM表"></a>对MyISAM表</h3><p>插入大量数据前：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> table_name <span class="keyword">DISABLE</span> <span class="keyword">KEYS</span>;  <span class="comment">/* 禁用索引 */</span></span><br><span class="line"><span class="keyword">SET</span> UNIQUE_CHECKS=<span class="number">0</span>;                  <span class="comment">/* 禁用唯一性校验 */</span></span><br></pre></td></tr></table></figure><p>插入时：</p><ol><li>使用一条INSERT语句插入多条记录。</li><li>如果需要导入数据，使用LOAD DATA INFILE语句，它比INSERT语句快。</li></ol><p>之后：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> table_name <span class="keyword">ENABLE</span> <span class="keyword">KEYS</span>;  <span class="comment">/* 开启索引 */</span></span><br><span class="line"><span class="keyword">SET</span> UNIQUE_CHECKS=<span class="number">1</span>;                 <span class="comment">/* 启用唯一性校验 */</span></span><br></pre></td></tr></table></figure><h3 id="对InnoDB表"><a href="#对InnoDB表" class="headerlink" title="对InnoDB表"></a>对InnoDB表</h3><p>插入大量数据前：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET</span> UNIQUE_CHECKS=<span class="number">0</span>;                  <span class="comment">/* 禁用唯一性校验 */</span></span><br><span class="line"><span class="keyword">SET</span> FOREIGN_KEY_CHECKS=<span class="number">0</span>;             <span class="comment">/* 禁用外键检查 */</span></span><br><span class="line"><span class="keyword">SET</span> AUTOCOMMIT=<span class="number">0</span>;                     <span class="comment">/* 禁止自动提交 */</span></span><br></pre></td></tr></table></figure><p>插入时的方法和MyISAM的一样。</p><p>之后：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET</span> UNIQUE_CHECKS=<span class="number">1</span>;                 <span class="comment">/* 启用唯一性校验 */</span></span><br><span class="line"><span class="keyword">SET</span> FOREIGN_KEY_CHECKS=<span class="number">1</span>;             <span class="comment">/* 恢复外键检查 */</span></span><br><span class="line"><span class="keyword">SET</span> AUTOCOMMIT=<span class="number">1</span>;                     <span class="comment">/* 恢复自动提交 */</span></span><br></pre></td></tr></table></figure><h2 id="优化表"><a href="#优化表" class="headerlink" title="优化表"></a>优化表</h2><ol><li>使用<code>ANALYZE TABLE</code>语句分析表</li><li>使用<code>CHECK TABLE</code>语句检查表</li><li>使用<code>OPTIMIZE TABLE</code>语句优化表</li></ol><p>这3种语句执行的时候都会给表加上只读锁，具体的用法可以查阅相关文档。</p><h2 id="优化服务器硬件配置"><a href="#优化服务器硬件配置" class="headerlink" title="优化服务器硬件配置"></a>优化服务器硬件配置</h2><ol><li>配备大内存</li><li>配备高速磁盘系统</li><li>合理分布磁盘I/O</li><li>配备高速多核处理器</li><li>配备大带宽网络</li></ol><h2 id="优化MySQL配置"><a href="#优化MySQL配置" class="headerlink" title="优化MySQL配置"></a>优化MySQL配置</h2><p>参见这篇文章：<a href="http://www.speedemy.com/17-key-mysql-config-file-settings-mysql-5-7-proof/" target="_blank" rel="noopener">http://www.speedemy.com/17-key-mysql-config-file-settings-mysql-5-7-proof/</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;对MySQL的各种优化方法的总结。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="mysql" scheme="https://zenxme.github.io/tags/mysql/"/>
    
      <category term="数据库" scheme="https://zenxme.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>先装ubuntu，再安装windows系统后，如何安装grub</title>
    <link href="https://zenxme.github.io/2019/03/26/%E5%85%88%E8%A3%85ubuntu%EF%BC%8C%E5%86%8D%E5%AE%89%E8%A3%85windows%E7%B3%BB%E7%BB%9F%E5%90%8E%EF%BC%8C%E5%A6%82%E4%BD%95%E5%AE%89%E8%A3%85grub/"/>
    <id>https://zenxme.github.io/2019/03/26/%E5%85%88%E8%A3%85ubuntu%EF%BC%8C%E5%86%8D%E5%AE%89%E8%A3%85windows%E7%B3%BB%E7%BB%9F%E5%90%8E%EF%BC%8C%E5%A6%82%E4%BD%95%E5%AE%89%E8%A3%85grub/</id>
    <published>2019-03-26T10:29:28.000Z</published>
    <updated>2020-03-11T06:43:10.355Z</updated>
    
    <content type="html"><![CDATA[<p>先装ubuntu，再安装windows系统后，如何安装grub接管开机启动。</p><a id="more"></a><p>网上推荐的安装双系统的方法，都是说要先装windows，再装ubuntu，这样最后可以用grub接管开机启动，在启动的时候可以选择进入ubuntu还是windows。</p><p>但是我安装的顺序是先ubuntu，再windows。windows安装的时候清除了grub，这样我每次想要换系统都得进入BIOS切换启动顺序，很不方便。之后我查阅了ubuntu的相关文档<a href="https://help.ubuntu.com/community/RecoveringUbuntuAfterInstallingWindows" target="_blank" rel="noopener">https://help.ubuntu.com/community/RecoveringUbuntuAfterInstallingWindows</a>，从而解决了这个问题。</p><p>我只采用了图形方式，命令行方式的我没有尝试。</p><p>操作步骤很简单，就是首先安装并启动<code>boot-repair</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo add-apt-repository ppa:yannubuntu/boot-repair</span><br><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install -y boot-repair &amp;&amp; boot-repair</span><br></pre></td></tr></table></figure><p>然后点击<code>Recommended repair</code>，等待完毕后重启即可。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;先装ubuntu，再安装windows系统后，如何安装grub接管开机启动。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="windows" scheme="https://zenxme.github.io/tags/windows/"/>
    
      <category term="ubuntu" scheme="https://zenxme.github.io/tags/ubuntu/"/>
    
      <category term="操作系统" scheme="https://zenxme.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>&#39;sudo -H&#39;的作用</title>
    <link href="https://zenxme.github.io/2019/03/19/sudo-H-%E7%9A%84%E4%BD%9C%E7%94%A8/"/>
    <id>https://zenxme.github.io/2019/03/19/sudo-H-%E7%9A%84%E4%BD%9C%E7%94%A8/</id>
    <published>2019-03-19T02:54:41.000Z</published>
    <updated>2020-03-11T06:43:10.354Z</updated>
    
    <content type="html"><![CDATA[<p>在用pip安装python库时候，经常会看到警告<code>&quot;The directory or its parent directory is not owned by the current user and caching wheels has been disabled..........</code>，然后就是建议使用<code>sudo -H</code>。那么这个问题的具体原因到底是什么呢？</p><a id="more"></a><h2 id="查阅sudo的文档"><a href="#查阅sudo的文档" class="headerlink" title="查阅sudo的文档"></a>查阅sudo的文档</h2><p>查阅：<a href="https://linux.die.net/man/8/sudo" target="_blank" rel="noopener">https://linux.die.net/man/8/sudo</a>，其中对-H参数的解释如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-H&#39; The -H (HOME) option requests that the security policy set the HOME environment variable to the home directory of the target user (root by default) as specified by the password database. Depending on the policy, this may be the default behavior.</span><br></pre></td></tr></table></figure><p>意思就是加了-H的参数以后会设置<code>HOME</code>这个环境变量到root的目录（默认情况下），那么我们手动测试一下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo python3</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Python <span class="number">3.6</span><span class="number">.7</span> (default, Oct <span class="number">22</span> <span class="number">2018</span>, <span class="number">11</span>:<span class="number">32</span>:<span class="number">17</span>) </span><br><span class="line">[GCC <span class="number">8.2</span><span class="number">.0</span>] on linux</span><br><span class="line">Type <span class="string">"help"</span>, <span class="string">"copyright"</span>, <span class="string">"credits"</span> <span class="keyword">or</span> <span class="string">"license"</span> <span class="keyword">for</span> more information.</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> os</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>os.environ[<span class="string">'HOME'</span>]</span><br><span class="line"><span class="string">'/home/hacker'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>os.environ[<span class="string">'USER'</span>]</span><br><span class="line"><span class="string">'root'</span></span><br></pre></td></tr></table></figure><p>加了-H参数之后</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo -H python3</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Python <span class="number">3.6</span><span class="number">.7</span> (default, Oct <span class="number">22</span> <span class="number">2018</span>, <span class="number">11</span>:<span class="number">32</span>:<span class="number">17</span>) </span><br><span class="line">[GCC <span class="number">8.2</span><span class="number">.0</span>] on linux</span><br><span class="line">Type <span class="string">"help"</span>, <span class="string">"copyright"</span>, <span class="string">"credits"</span> <span class="keyword">or</span> <span class="string">"license"</span> <span class="keyword">for</span> more information.</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> os</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>os.environ[<span class="string">'HOME'</span>]</span><br><span class="line"><span class="string">'/root'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>os.environ[<span class="string">'USER'</span>]</span><br><span class="line"><span class="string">'root'</span></span><br></pre></td></tr></table></figure><p>所以结果就很明显了，确实环境变量里的<code>HOME</code>被改成了root的目录。</p><h2 id="查看pip源码"><a href="#查看pip源码" class="headerlink" title="查看pip源码"></a>查看pip源码</h2><p>那么到底pip为什么需要这个变量呢，我查阅了位于github上的pip的源码，在这里<a href="https://github.com/pypa/pip/blob/3a77bd667cc68935040563e1351604c461ce5333/src/pip/_internal/commands/download.py" target="_blank" rel="noopener">https://github.com/pypa/pip/blob/3a77bd667cc68935040563e1351604c461ce5333/src/pip/_internal/commands/download.py</a>我找到了这段提示信息。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> options.cache_dir <span class="keyword">and</span> <span class="keyword">not</span> check_path_owner(options.cache_dir):</span><br><span class="line">    logger.warning(</span><br><span class="line">        <span class="string">"The directory '%s' or its parent directory is not owned "</span></span><br><span class="line">        <span class="string">"by the current user and caching wheels has been "</span></span><br><span class="line">        <span class="string">"disabled. check the permissions and owner of that "</span></span><br><span class="line">        <span class="string">"directory. If executing pip with sudo, you may want "</span></span><br><span class="line">        <span class="string">"sudo's -H flag."</span>,</span><br><span class="line">        options.cache_dir,</span><br><span class="line">    )</span><br><span class="line">    options.cache_dir = <span class="literal">None</span></span><br></pre></td></tr></table></figure><p>根据代码变量的命名，很容易就可以知道这段代码的意思。如果说缓存目录存在，但是不属于当前用户的话，就发出警告，并且不缓存wheels。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在用pip安装python库时候，经常会看到警告&lt;code&gt;&amp;quot;The directory or its parent directory is not owned by the current user and caching wheels has been disabled..........&lt;/code&gt;，然后就是建议使用&lt;code&gt;sudo -H&lt;/code&gt;。那么这个问题的具体原因到底是什么呢？&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="bash" scheme="https://zenxme.github.io/tags/bash/"/>
    
  </entry>
  
  <entry>
    <title>MySQL插入utf8mb4编码的文本</title>
    <link href="https://zenxme.github.io/2019/03/18/MySQL%E6%8F%92%E5%85%A5utf8mb4%E7%BC%96%E7%A0%81%E7%9A%84%E6%96%87%E6%9C%AC/"/>
    <id>https://zenxme.github.io/2019/03/18/MySQL%E6%8F%92%E5%85%A5utf8mb4%E7%BC%96%E7%A0%81%E7%9A%84%E6%96%87%E6%9C%AC/</id>
    <published>2019-03-18T09:01:11.000Z</published>
    <updated>2020-03-11T06:43:10.352Z</updated>
    
    <content type="html"><![CDATA[<p>今天在爬取淘宝的评论的时候，在向MySQL数据库里插入带有表情的评论文本，结果出现了<code>Incorrect string value: ‘\xF0\x9F\x98\x83.....</code>的报错，在此记录下对这个问题的学习。</p><a id="more"></a><h2 id="问题的原因"><a href="#问题的原因" class="headerlink" title="问题的原因"></a>问题的原因</h2><p>淘宝有些评论里面是有表情的，而这些表情是utf8文本，但是不是普通的utf8文本，而是特殊的utf8文本，它无法在MySQL的<code>utf8</code>编码下存储，只能存储到<code>utf8mb4</code>编码的字段中。</p><h2 id="MySQL里的utf8不是真正的utf8"><a href="#MySQL里的utf8不是真正的utf8" class="headerlink" title="MySQL里的utf8不是真正的utf8"></a>MySQL里的utf8不是真正的utf8</h2><p>具体可以参见这篇文章<a href="https://medium.com/@adamhooper/in-mysql-never-use-utf8-use-utf8mb4-11761243e434" target="_blank" rel="noopener">https://medium.com/@adamhooper/in-mysql-never-use-utf8-use-utf8mb4-11761243e434</a></p><p>总结就是</p><ul><li>MySQL里的<code>utfmb4</code>意思是真正的的<code>utf8</code>（就是完全实现）</li><li>MySQL里的<code>utf8</code>不能编码许多Unicode字符</li></ul><h2 id="如何解决这个问题"><a href="#如何解决这个问题" class="headerlink" title="如何解决这个问题"></a>如何解决这个问题</h2><p>在网上我查到了许多教程，大致就是用python向数据库里插入utf8mb4编码的数据的时候，要保证数据库、表、字段都得是utf8mb4编码的，以及在连接的开始的时候也要执行<code>SET NAMES utf8mb4</code>。</p><p>但是我经过实践以后可以发现，只要保证字段是utf8mb4编码的，就可以向里面插入utf8mb4编码的文本。可以和表、数据库的类型不一致。表、数据库我这边默认的编码是utf8，这两个在stack overflow上查了相关回答之后得知应该是兼容的。</p><p>创建一个表<code>test_table</code></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; create table test_table(</span><br><span class="line">    -&gt; name varchar(200) null</span><br><span class="line">    -&gt; ) default charset utf8 collate utf8_general_ci;</span><br><span class="line">Query OK, 0 rows affected (0.05 sec)</span><br></pre></td></tr></table></figure><p>插入一段带表情的文本，这个时候出错了</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; insert into test_table(name) values ('😃 &lt;');</span><br><span class="line">ERROR 1366 (HY000): Incorrect string value: '\xF0\x9F\x98\x83 &lt;' for column 'name' at row 1</span><br></pre></td></tr></table></figure><p>这个时候看一下<code>SHOW CREATE test_table</code></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">+<span class="comment">------------+-----------------------------------------------------------------------------------------------------+</span></span><br><span class="line">| Table      | <span class="keyword">Create</span> <span class="keyword">Table</span>                                                                                        |</span><br><span class="line">+<span class="comment">------------+-----------------------------------------------------------------------------------------------------+</span></span><br><span class="line">| test_table | <span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`test_table`</span> (</span><br><span class="line">  <span class="string">`name`</span> <span class="built_in">varchar</span>(<span class="number">200</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span></span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8 |</span><br><span class="line">+<span class="comment">------------+-----------------------------------------------------------------------------------------------------+</span></span><br><span class="line"><span class="number">1</span> <span class="keyword">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure><p>修改下表的编码</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; alter table test_table modify column name varchar(200) character set utf8mb4 collate utf8mb4_general_ci;</span><br><span class="line">Query OK, 0 rows affected (0.15 sec)</span><br><span class="line">Records: 0  Duplicates: 0  Warnings: 0</span><br></pre></td></tr></table></figure><p>再次运行<code>SHOW CREATE test_table</code></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show create table test_table;</span><br><span class="line">+<span class="comment">------------+---------------------------------------------------------------------------------------------------------------------------+</span></span><br><span class="line">| Table      | <span class="keyword">Create</span> <span class="keyword">Table</span>                                                                                                              |</span><br><span class="line">+<span class="comment">------------+---------------------------------------------------------------------------------------------------------------------------+</span></span><br><span class="line">| test_table | <span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`test_table`</span> (</span><br><span class="line">  <span class="string">`name`</span> <span class="built_in">varchar</span>(<span class="number">200</span>) <span class="built_in">CHARACTER</span> <span class="keyword">SET</span> utf8mb4 <span class="keyword">DEFAULT</span> <span class="literal">NULL</span></span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8 |</span><br><span class="line">+<span class="comment">------------+---------------------------------------------------------------------------------------------------------------------------+</span></span><br></pre></td></tr></table></figure><p>可以看到，表的编码是utf8，但是name字段的是utf8mb4。这个时候我再进行插入</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; insert into test_table(name) values ('😃 &lt;');</span><br><span class="line">ERROR 1366 (HY000): Incorrect string value: '\xF0\x9F\x98\x83 &lt;' for column 'name' at row 1</span><br></pre></td></tr></table></figure><p>还是不行。那么我运行一下<code>SET NAMES utf8;</code></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SET NAMES utf8mb4;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br></pre></td></tr></table></figure><p>再次插入</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; insert into test_table(name) values ('😃 &lt;');</span><br><span class="line">Query OK, 1 row affected (0.03 sec)</span><br></pre></td></tr></table></figure><p>这个时候已经OK了，执行一下查询看看。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select * from test_table;</span><br><span class="line">+<span class="comment">--------+</span></span><br><span class="line">| name   |</span><br><span class="line">+<span class="comment">--------+</span></span><br><span class="line">| 😃 &lt;     |</span><br><span class="line">+<span class="comment">--------+</span></span><br><span class="line">1 row in <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure><h2 id="SET-NAMES执行的时候发生了什么"><a href="#SET-NAMES执行的时候发生了什么" class="headerlink" title="SET NAMES执行的时候发生了什么"></a>SET NAMES执行的时候发生了什么</h2><p>设置了3个session变量。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET</span> character_set_client = charset_name;</span><br><span class="line"><span class="keyword">SET</span> character_set_results = charset_name;</span><br><span class="line"><span class="keyword">SET</span> character_set_connection = charset_name;</span><br></pre></td></tr></table></figure><p>详细的可以查看这篇“阿里云RDS-数据库内核组”的文章<a href="http://mysql.taobao.org/monthly/2015/05/07/" target="_blank" rel="noopener">http://mysql.taobao.org/monthly/2015/05/07/</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天在爬取淘宝的评论的时候，在向MySQL数据库里插入带有表情的评论文本，结果出现了&lt;code&gt;Incorrect string value: ‘\xF0\x9F\x98\x83.....&lt;/code&gt;的报错，在此记录下对这个问题的学习。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="mysql" scheme="https://zenxme.github.io/tags/mysql/"/>
    
      <category term="编码" scheme="https://zenxme.github.io/tags/%E7%BC%96%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>selenium爬虫总结</title>
    <link href="https://zenxme.github.io/2019/03/15/selenium%E7%88%AC%E8%99%AB%E6%80%BB%E7%BB%93/"/>
    <id>https://zenxme.github.io/2019/03/15/selenium%E7%88%AC%E8%99%AB%E6%80%BB%E7%BB%93/</id>
    <published>2019-03-15T09:47:29.000Z</published>
    <updated>2020-03-11T06:43:10.354Z</updated>
    
    <content type="html"><![CDATA[<p>对自己在使用selenium对有复杂加密的网站的爬取过程中遇到的问题做总结。</p><a id="more"></a><h2 id="selenium的基本用法"><a href="#selenium的基本用法" class="headerlink" title="selenium的基本用法"></a>selenium的基本用法</h2><p>我一般都使用Chrome浏览器</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium.webdriver <span class="keyword">import</span> Chrome, ChromeOptions</span><br><span class="line"></span><br><span class="line">chrome_options = ChromeOptions()</span><br><span class="line">driver = Chrome(options=chrome_options, executable_path=<span class="string">'./chromedriver'</span>)</span><br><span class="line">driver.get(<span class="string">'https://www.google.com/'</span>)</span><br></pre></td></tr></table></figure><p>可以调用<code>chrome_options</code>的方法来添加各种参数和设置，然后在生成<code>Chrome</code>对象的时候传递进去。</p><p><code>chrome_options</code>常用的方法:</p><ul><li><code>add_extension</code>(添加扩展)</li><li><code>add_argument</code>(添加参数)</li><li><code>set_headless</code>(设为无头浏览器)</li></ul><h2 id="等待页面加载完毕"><a href="#等待页面加载完毕" class="headerlink" title="等待页面加载完毕"></a>等待页面加载完毕</h2><ol><li><p><code>sleep</code></p><p>这个就是time模块里的sleep函数，让解释器停止运行一段时间，这样有个弊端就是无论这期间页面加载完毕了没有，都不会停止sleep，相当于浪费时间。</p></li><li><p><code>implicitly_wait</code></p><p>即隐式等待，这个是driver的方法，比如<code>driver.implicitly_wait(15)</code>，就是设置隐式等待时间为15秒，这个设置好之后，在整个driver的生命周期内都起作用。意思相当于设置了一个最长等待时间，等待的是<strong>整个页面</strong>的加载完毕。如果超过了这个时间，还是没有加载好，那就会接着往下运行，那么下面就开有可能会出错。如果没超过这个时间就加载好了，那就直接往下运行，无需再等待。</p></li><li><p><code>WebDriverWait</code></p><p>即显式等待。可以指定等待<strong>某个元素</strong>的出现比如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.support.wait <span class="keyword">import</span> WebDriverWait</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.support <span class="keyword">import</span> expected_conditions <span class="keyword">as</span> EC</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.common.by <span class="keyword">import</span> By</span><br><span class="line"></span><br><span class="line">driver = webdriver.Chrome()</span><br><span class="line">driver.implicitly_wait(<span class="number">15</span>)</span><br><span class="line">driver.get(<span class="string">'https://www.google.com/'</span>)</span><br><span class="line">locator = (By.ID, <span class="string">'gsr'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    ele = WebDriverWait(driver, <span class="number">20</span>).until(EC.presence_of_element_located(locator))</span><br><span class="line"><span class="keyword">finally</span>:</span><br><span class="line">    driver.quit()</span><br></pre></td></tr></table></figure><p>隐性等待和显性等待可以同时用，等待的最长时间取两者之中的大者。</p><p>完整的等待状态列表可以看这里:<a href="https://selenium-python-zh.readthedocs.io/en/latest/api.html?highlight=expected%20conditions%20suppor#module-selenium.webdriver.support.expected_conditions" target="_blank" rel="noopener">module-selenium.webdriver.support.expected_conditions</a></p></li></ol><h2 id="查找元素"><a href="#查找元素" class="headerlink" title="查找元素"></a>查找元素</h2><p>driver和web element都可以通过多种方法查找想要的元素，比如有<code>find_element_by_id</code>、<code>find_element_by_css_selector</code>、<code>find_element_by_xpath</code>等等。给方法名里的element加s就可以找所有符合条件的元素。</p><p>   <strong>如果遇到有iframe的</strong></p><p>   先<code>driver.switch_to.frame(iframe)</code>，然后再查找元素，完毕之后，再调用<code>driver.switch_to.default_content()</code>跳出这个iframe。</p><h2 id="如何新开一个标签页"><a href="#如何新开一个标签页" class="headerlink" title="如何新开一个标签页"></a>如何新开一个标签页</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">driver.execute_script(<span class="string">"window.open('about:blank','_blank');"</span>)  <span class="comment"># 新开一个空白标签页</span></span><br><span class="line">driver.switch_to.window(driver.window_handles[len(driver.window_handles) - <span class="number">1</span>])  <span class="comment"># 进入新开的标签页</span></span><br><span class="line">driver.get(<span class="string">'https//www.google.com/'</span>)  <span class="comment"># 打开链接</span></span><br><span class="line"><span class="comment"># ......</span></span><br><span class="line">driver.close()  <span class="comment"># 关闭当前的标签页</span></span><br><span class="line">driver.switch_to.window(self.driver.window_handles[len(self.driver.window_handles) - <span class="number">1</span>])  <span class="comment"># 回到前一个标签页，或者其他的，可以任意指定</span></span><br></pre></td></tr></table></figure><p><strong>注意</strong>：<code>driver.close</code>和<code>driver.quit</code>的不同。</p><p>close方法的文档是：Closes the current window.”，仅仅关闭当前的窗口。</p><p>而quit方法的文档里写的是：”Closes the browser and shuts down the ChromeDriver executable that is started when starting the ChromeDriver”，意思就是完全退出了。</p><h2 id="键盘鼠标模拟操作"><a href="#键盘鼠标模拟操作" class="headerlink" title="键盘鼠标模拟操作"></a>键盘鼠标模拟操作</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium.webdriver <span class="keyword">import</span> ActionChains</span><br><span class="line"><span class="comment"># ......</span></span><br><span class="line"><span class="comment"># element = xxx</span></span><br><span class="line">action = ActionChains(driver)</span><br><span class="line">action.move_to_element(element).perform()</span><br><span class="line">action.click().perform()</span><br><span class="line">action.send_keys(<span class="string">'abcdefg'</span>)</span><br><span class="line"></span><br><span class="line">action.click_and_hold(swipe_button).perform()  <span class="comment"># 点击按住鼠标</span></span><br><span class="line">action.move_by_offset(<span class="number">580</span>, <span class="number">0</span>).perform()  <span class="comment"># 拖动</span></span><br></pre></td></tr></table></figure><p>详细信息见:<a href="https://selenium-python-zh.readthedocs.io/en/latest/api.html?highlight=actionchains#module-selenium.webdriver.common.action_chains" target="_blank" rel="noopener">module-selenium.webdriver.common.action_chains</a></p><h2 id="反反爬虫"><a href="#反反爬虫" class="headerlink" title="反反爬虫"></a>反反爬虫</h2><ol><li><p>隐藏<code>window.navigator.webdriver</code></p><p>正常通过driver启动的浏览器，会有一些和正常的浏览器不同的值。在js里调用<code>window.navigator.webdriver</code>，对driver启动的返回True，对正常的浏览器返回False。有些网站可能会通过这个值来禁止selenium的爬取。</p><p>解决方法：<code>chrome_option.add_experimental_option(&#39;excludeSwitches&#39;, [&#39;enable-automation&#39;])</code>，这样设置chrome_option以后，启动的浏览器里这个值<code>window.navigator.webdriver</code>就和正常浏览器的一样了。</p></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;对自己在使用selenium对有复杂加密的网站的爬取过程中遇到的问题做总结。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="python" scheme="https://zenxme.github.io/tags/python/"/>
    
      <category term="爬虫" scheme="https://zenxme.github.io/tags/%E7%88%AC%E8%99%AB/"/>
    
      <category term="selenium" scheme="https://zenxme.github.io/tags/selenium/"/>
    
  </entry>
  
  <entry>
    <title>MySQL数据类型总结</title>
    <link href="https://zenxme.github.io/2019/03/13/MySQL%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>https://zenxme.github.io/2019/03/13/MySQL%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</id>
    <published>2019-03-13T02:52:50.000Z</published>
    <updated>2020-03-13T12:54:00.711Z</updated>
    
    <content type="html"><![CDATA[<p>对MySQL数据类型INT、FLOAT、DOUBLE、YEAR、DATE等的学习和记录。</p><a id="more"></a><h2 id="整数类型"><a href="#整数类型" class="headerlink" title="整数类型"></a>整数类型</h2><table><thead><tr><th>类型</th><th>占用空间</th><th>有符号数值范围</th><th>无符号数值范围</th></tr></thead><tbody><tr><td>TINYINT</td><td>1字节</td><td>(-2^7) ~ (2^7 - 1)</td><td>0 ~ (2^8 - 1)</td></tr><tr><td>SMALLINT</td><td>2字节</td><td>(-2^15) ~ (2^15 - 1)</td><td>0 ~ (2^16 - 1)</td></tr><tr><td>MEDIUMINT</td><td>3字节</td><td>(-2^23) ~ (2^23 - 1)</td><td>0 ~ (2^24 - 1)</td></tr><tr><td>INT(INTEGER)</td><td>4字节</td><td>(-2^31) ~ (2^31 - 1)</td><td>0 ~ (2^32 - 1)</td></tr><tr><td>BIGINT</td><td>8字节</td><td>(-2^63) ~ (2^63 - 1)</td><td>0 ~ (2^64 - 1)</td></tr></tbody></table><p>创建表时，可以指定显示宽度，比如：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> test_table (id1 <span class="built_in">INT</span>(<span class="number">11</span>));</span><br></pre></td></tr></table></figure><p>我之前误以为这个11是存储位数，但是其实这里的11只是控制交互工具显示的宽度而已。</p><p>如果不指定显示宽度，那么会有一个默认的显示宽度存在，这个宽度可以保证每种数据类型可以保证可以显示该范围之内的所有值（如果是有负号数的话，包括负号的长度）。</p><p>如果数值的长度大于显示宽度，那么不会影响该数值的显示。如果小于显示宽度的话，就默认在左边补空格。</p><h2 id="浮点数和定点数类型"><a href="#浮点数和定点数类型" class="headerlink" title="浮点数和定点数类型"></a>浮点数和定点数类型</h2><p>浮点数：单精度浮点数(FLOAT)和双精度(DOUBLE)。</p><p>定点数：DECIMAL。</p><p>浮点数和定点数都可以用（M, N）来表示，其中M称为精度，表示总共的位数；N称为标度，表示小数的位数。比如DECIMAL(18, 9) 表示总共18位，取9位存储小数部分，剩下9位存储整数部分。</p><p>FLOAT占用4个字节，DOUBLE占用8个字节，DECIMAL占用M+2个字节。</p><p>FLOAT和DOUBLE在不指定精度时，默认会由计算机硬件和操作系统决定。DECIMAL如不指定，默认为(10, 0)。</p><p>CPU原生支持浮点数运算，但是不支持定点数运算，因为在MySQL里，定点数以字符串形式存储。</p><p>在对精度要求比较高的时候（如货币、科学数据等），使用DECIMAL类型比较好。</p><h2 id="日期和时间类型"><a href="#日期和时间类型" class="headerlink" title="日期和时间类型"></a>日期和时间类型</h2><table><thead><tr><th>类型</th><th>占用空间</th><th>日期格式</th><th>日期范围</th></tr></thead><tbody><tr><td>YEAR</td><td>1字节</td><td>YYYY</td><td>1901 ~ 2155</td></tr><tr><td>TIME</td><td>3字节</td><td>HH:MM:SS</td><td>-838:59:59 ~ 838:59:59</td></tr><tr><td>DATE</td><td>3字节</td><td>YYYY-MM-DD</td><td>1000-01-01 ~ 9999-12-3</td></tr><tr><td>DATETIME</td><td>8字节</td><td>YYYY-MM-DD HH:MM:SS</td><td>1000-01-01 00:00:00 ~ 9999-12-31 23:59:59</td></tr><tr><td>TIMESTAMP</td><td>4字节</td><td>YYYY-MM-DD HH:MM:SS</td><td>1970-01-01 00:00:00 UTC ~ 2038-01-19 03:14:07 UTC</td></tr></tbody></table><p>MySQL 允许不严格语法：任何标点符号都可以用作日期部分或时间部分之间的间隔符。</p><p>TIMESTAMP存储和查询时，都会根据当前的时区进行转换。</p><h2 id="文本字符串类型"><a href="#文本字符串类型" class="headerlink" title="文本字符串类型"></a>文本字符串类型</h2><table><thead><tr><th>类型名称</th><th>占用空间</th><th>说明</th></tr></thead><tbody><tr><td>CHAR(M)</td><td>M字节，1&lt;=M&lt;=255</td><td>固定长度的字符串</td></tr><tr><td>VARCHAR(M)</td><td>L+1字节，L&lt;=M且1&lt;=M&lt;=65535</td><td>变长字符串</td></tr><tr><td>TINYTEXT</td><td>L+1字节，L&lt;2^8</td><td></td></tr><tr><td>TEXT</td><td>L+2字节，L&lt;2^16</td><td></td></tr><tr><td>MEDIUMTEXT</td><td>L+3字节，L&lt;2^24</td><td></td></tr><tr><td>LONGTEXT</td><td>L+4字节，L&lt;2^32</td><td></td></tr><tr><td>ENUM</td><td>1或2个字节，取决于枚举值的数目(最大值65535)</td><td>枚举类型</td></tr><tr><td>SET</td><td>1、2、3、4或8个字节，取决于集合成员的数量</td><td>集合</td></tr></tbody></table><p>VARCHAR和TEXT是变长类型，其实际存储需求取决于列值的实际长度。比如一列是VARCHAR(10)，存储了”abcd”的时候，L为4，占用的空间为5个字节，多出来的一个字节用来记录字符串的长度。</p><p>CHAR是固定长度的类型，在定义时指定长度。</p><p>VARCHAR的实际长度由最长的行的大小和使用的字符集确定。</p><p>CHAR在保存时，如果长度不够就在右侧填充空格；在检索时尾部的空格将被删除。而VARCHAR在保存和检索时尾部的空格仍然保留。</p><p>ENUM和SET以字符串形式出现，但是在MySQL内部以数值的形式存储。</p><h2 id="二进制字符串类型"><a href="#二进制字符串类型" class="headerlink" title="二进制字符串类型"></a>二进制字符串类型</h2><table><thead><tr><th>类型名称</th><th>占用空间</th><th>说明</th></tr></thead><tbody><tr><td>BIT(M)</td><td>大约(M+7)/8个字节</td><td>位字段类型</td></tr><tr><td>BINARY(M)</td><td>M个字节</td><td>固定长度二进制字符串</td></tr><tr><td>VARBINARY(M)</td><td>M+1个字节</td><td>可变长度二进制字符串</td></tr><tr><td>TINYBLOB(M)</td><td>L+1字节，L&lt;2^8</td><td></td></tr><tr><td>BLOB(M)</td><td>L+2字节，L&lt;2^16</td><td></td></tr><tr><td>MEDIUMBLOB(M)</td><td>L+3字节，L&lt;2^24</td><td></td></tr><tr><td>LONGBLOB(M)</td><td>L+4字节，L&lt;2^32</td><td></td></tr></tbody></table><h2 id="如何选择存储类型"><a href="#如何选择存储类型" class="headerlink" title="如何选择存储类型"></a>如何选择存储类型</h2><p>为了优化存储，提高数据库的性能，在任何情况下均应使用最精确的类型。即在所有可以表示该列的类型中，该类型使用的存储最少。可以简略总结如下：</p><ul><li>如果不需要小数部分，则选择整数类型；如果需要小数部分，则选择浮点数类型。如果精确度要求不高，则选择FLOAT类型；如果精确度要求高，则选择DOUBLE类型。如果要更高的精确度要求，以及要进行数值比较的话，可以选择DECIMAL类型。</li><li>如果只需要记录年份，则选择YEAR类型；只记录日期，则选择DATE类型；只记录时间，则选择TIME类型；如果同时记录日期和时间，如果范围小的选择TIMESTAMP，大的选择DATETIME。</li><li>对于MyISAM存储引擎，最好使用固定长度的数据列代替可变长度的数据列，这样可以使整个表静态化，从而使数据检索更快，用空间换时间。</li><li>对于InnoDB存储引擎，使用可变长度的数据列，因为InnoDB数据表的存储格式不分固定长度和可变长度，因此使用CHAR不一定比VARCHAR更好，但是由于VARCHAR是按照实际的长度存储，比较节省空间，所以对磁盘I/O和数据存储比较好。</li><li>ENUM类型的例子：性别字段，只能取<code>男</code>或者<code>女</code>。</li><li>SET类型的例子：存储某人的兴趣爱好。</li><li>二进制字符串用来存储图片、音频等二进制数据，文本字符串用来存储文本数据。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;对MySQL数据类型INT、FLOAT、DOUBLE、YEAR、DATE等的学习和记录。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="mysql" scheme="https://zenxme.github.io/tags/mysql/"/>
    
      <category term="数据库" scheme="https://zenxme.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>MySQL存储引擎总结</title>
    <link href="https://zenxme.github.io/2019/03/12/MySQL%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>https://zenxme.github.io/2019/03/12/MySQL%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</id>
    <published>2019-03-12T09:32:51.000Z</published>
    <updated>2020-03-11T06:43:10.352Z</updated>
    
    <content type="html"><![CDATA[<p>对MySQL存储引擎InnoDB、MyISAM、MEMORY的学习和记录。</p><a id="more"></a><p>在MySQL中，使用<code>SHOW ENGINES</code>命令可以查看所支持的引擎，我当前的版本是5.7，可以看到有如下的输出。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SHOW ENGINES;</span><br><span class="line">+--------------------+---------+----------------------------------------------------------------+--------------+------+------------+</span><br><span class="line">| Engine             | Support | Comment                                                        | Transactions | XA   | Savepoints |</span><br><span class="line">+--------------------+---------+----------------------------------------------------------------+--------------+------+------------+</span><br><span class="line">| InnoDB             | DEFAULT | Supports transactions, row-level locking, and foreign keys     | YES          | YES  | YES        |</span><br><span class="line">| MRG_MYISAM         | YES     | Collection of identical MyISAM tables                          | NO           | NO   | NO         |</span><br><span class="line">| MEMORY             | YES     | Hash based, stored in memory, useful for temporary tables      | NO           | NO   | NO         |</span><br><span class="line">| BLACKHOLE          | YES     | &#x2F;dev&#x2F;null storage engine (anything you write to it disappears) | NO           | NO   | NO         |</span><br><span class="line">| MyISAM             | YES     | MyISAM storage engine                                          | NO           | NO   | NO         |</span><br><span class="line">| CSV                | YES     | CSV storage engine                                             | NO           | NO   | NO         |</span><br><span class="line">| ARCHIVE            | YES     | Archive storage engine                                         | NO           | NO   | NO         |</span><br><span class="line">| PERFORMANCE_SCHEMA | YES     | Performance Schema                                             | NO           | NO   | NO         |</span><br><span class="line">| FEDERATED          | NO      | Federated MySQL storage engine                                 | NULL         | NULL | NULL       |</span><br><span class="line">+--------------------+---------+----------------------------------------------------------------+--------------+------+------------+</span><br></pre></td></tr></table></figure><h2 id="InnoDB"><a href="#InnoDB" class="headerlink" title="InnoDB"></a>InnoDB</h2><p>InnoDB是MySQL5.5.5之后的默认存储引擎，主要特性有：</p><ul><li>支持事务，每一条SQL语句都默认封装成事务，具有提交、回滚和崩溃恢复能力。</li><li>事务具有ACID特性，还实现了4个标准的隔离级别：未提交读(Read uncommitted)，已提交读(Read committed)，可重复读(Repeatable read)，可串行化(Serializable)。</li><li>支持外键完整性约束(FOREIGN KEY)。</li><li>索引是聚集索引，数据文件是和索引绑在一起的(ibdata文件)，必须要有主键(如果没有定义主键，那么该表的第一个唯一非空索引被作为聚集索引。如果这两种情况都没有，那么会自动生成一个隐藏的主键作为聚集索引，这个隐藏的主键是一个6个字节的列，该列的值会随着数据的插入自增)。</li><li>不保存表的具体行数，执行<code>select count(*) from table_name</code>时需要全表扫描。</li><li>支持行级锁和表级锁。</li><li>支持在线热备份。</li></ul><h2 id="MyISAM"><a href="#MyISAM" class="headerlink" title="MyISAM"></a>MyISAM</h2><p>MyISAM是MySQL5.5.5之前的默认存储引擎，主要特性有：</p><ul><li>不支持事务。</li><li>不支持外键。</li><li>数据和索引分开存储的，分为3个文件，文件名是表名，扩展名指出了类型。<code>.frm</code>(format的缩写)文件存储表定义，<code>.MYD</code>(MYData)存储表数据，<code>.MYI</code>(MYIndex)存储索引文件。</li><li>用一个变量保存了整个表的行数，执行<code>select count(*) from table_name</code>时只需要读出该变量即可，速度很快。</li><li>不支持行级锁，只支持表级锁。</li><li>每个字符列可以有不同的字符集。</li></ul><p>注意：在SQL查询中，可以自由地将InnoDB类型的表和其它类型的表混合起来，甚至在同一个查询中也可以混合。但是如果把一个含有外键的InnoDB类型的表转换为MyISAM的话则会失败。</p><h2 id="MEMORY"><a href="#MEMORY" class="headerlink" title="MEMORY"></a>MEMORY</h2><p>MEMORY存储引擎将表中的数据存储到内存中，为查询和其它表数据提供快速访问，主要特性有：</p><ul><li>每个表有多达32个索引，每个索引16列，以及500B的最大键长度。</li><li>执行HASH和BTREE索引。</li><li>使用一个固定的记录长度的格式。</li><li>不支持BLOB或TEXT列。</li><li>在所有客户端之间共享，就像其它任何非TEMPORARY表。</li><li>内容被存在内存中，当不再需要表里的内容时，要释放该表所使用的内存，应该清空表里的数据，或者直接删除表。</li></ul><h2 id="如何选择存储引擎"><a href="#如何选择存储引擎" class="headerlink" title="如何选择存储引擎"></a>如何选择存储引擎</h2><p>以下摘自&lt;&lt;MySQL5.7从入门到精通&gt;&gt;</p><blockquote><p>如果要提供提交、回滚和崩溃恢复能力的事务安全（ACID兼容）能力，并要求实现并发控制，InnoDB是个很好的选择。如果数据主要用来插入和查询记录，则MyISAM引擎能提供较高的处理效率；如果只是临时存放数据，数据量不大，并且不需要较高的数据安全性，可以选择将数据保存在内存中的Memory引擎，MySQL中使用该引擎作为临时表，存放查询的中间结果。如果只有INSERT和SELECT操作，可以选择Archive引擎，Archive存储引擎支持高并发的插入操作，但是本身并不是事务安全的。Archive存储引擎非常适合存储归档数据，如记录日志信息可以使用Archive引擎。</p><p>使用哪一种引擎要根据需要灵活选择，一个数据库中多个表可以使用不同引擎以满足各种性能和实际需求。使用合适的存储引擎，将会提高整个数据库的性能。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;对MySQL存储引擎InnoDB、MyISAM、MEMORY的学习和记录。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="mysql" scheme="https://zenxme.github.io/tags/mysql/"/>
    
      <category term="数据库" scheme="https://zenxme.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>python的赋值和参数传递</title>
    <link href="https://zenxme.github.io/2018/12/24/python%E7%9A%84%E8%B5%8B%E5%80%BC%E5%92%8C%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92/"/>
    <id>https://zenxme.github.io/2018/12/24/python%E7%9A%84%E8%B5%8B%E5%80%BC%E5%92%8C%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92/</id>
    <published>2018-12-24T12:26:13.000Z</published>
    <updated>2020-03-11T06:43:10.353Z</updated>
    
    <content type="html"><![CDATA[<p>最近在看python的面试题的时候，遇到这个问题“python是值传递还是引用传递”，因此记录下我对这个问题的学习和思考。</p><a id="more"></a><h2 id="一切皆对象"><a href="#一切皆对象" class="headerlink" title="一切皆对象"></a>一切皆对象</h2><p>在python里，一切皆对象（Everything in Python is an object）。</p><p>数字、字符串、元组、列表、字典、函数、方法、类、模块等等都是对象。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>type(<span class="number">3</span>)</span><br><span class="line">&lt;<span class="class"><span class="keyword">class</span> '<span class="title">int</span>'&gt;</span></span><br><span class="line"><span class="class">&gt;&gt;&gt; <span class="title">type</span><span class="params">(<span class="number">3.2</span>)</span></span></span><br><span class="line"><span class="class">&lt;<span class="title">class</span> '<span class="title">float</span>'&gt;</span></span><br><span class="line"><span class="class">&gt;&gt;&gt; <span class="title">type</span><span class="params">(<span class="string">'hello'</span>)</span></span></span><br><span class="line"><span class="class">&lt;<span class="title">class</span> '<span class="title">str</span>'&gt;</span></span><br><span class="line"><span class="class">&gt;&gt;&gt; <span class="title">type</span><span class="params">(<span class="params">()</span>)</span></span></span><br><span class="line"><span class="class">&lt;<span class="title">class</span> '<span class="title">tuple</span>'&gt;</span></span><br><span class="line"><span class="class">&gt;&gt;&gt; <span class="title">type</span><span class="params">([])</span></span></span><br><span class="line"><span class="class">&lt;<span class="title">class</span> '<span class="title">list</span>'&gt;</span></span><br><span class="line"><span class="class">&gt;&gt;&gt; <span class="title">type</span><span class="params">(&#123;&#125;)</span></span></span><br><span class="line"><span class="class">&lt;<span class="title">class</span> '<span class="title">dict</span>'&gt;</span></span><br><span class="line"><span class="class">&gt;&gt;&gt; <span class="title">def</span> <span class="title">func</span><span class="params">()</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">pass</span></span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>type(func)</span><br><span class="line">&lt;<span class="class"><span class="keyword">class</span> '<span class="title">function</span>'&gt;</span></span><br><span class="line"><span class="class">&gt;&gt;&gt; <span class="title">class</span> <span class="title">A</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">method</span><span class="params">(self)</span>:</span></span><br><span class="line"><span class="meta">... </span>        <span class="keyword">pass</span></span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>type(A)</span><br><span class="line">&lt;<span class="class"><span class="keyword">class</span> '<span class="title">type</span>'&gt;</span></span><br><span class="line"><span class="class">&gt;&gt;&gt; <span class="title">type</span><span class="params">(A.method)</span></span></span><br><span class="line"><span class="class">&lt;<span class="title">class</span> '<span class="title">function</span>'&gt;</span></span><br><span class="line"><span class="class">&gt;&gt;&gt; <span class="title">import</span> <span class="title">sys</span></span></span><br><span class="line"><span class="class">&gt;&gt;&gt; <span class="title">type</span><span class="params">(sys)</span></span></span><br><span class="line"><span class="class">&lt;<span class="title">class</span> '<span class="title">module</span>'&gt;</span></span><br><span class="line"><span class="class">&gt;&gt;&gt; <span class="title">type</span><span class="params">(type)</span></span></span><br><span class="line"><span class="class">&lt;<span class="title">class</span> '<span class="title">type</span>'&gt;</span></span><br></pre></td></tr></table></figure><h2 id="对象的特性"><a href="#对象的特性" class="headerlink" title="对象的特性"></a>对象的特性</h2><p>python的所有对象都有3个特性：</p><ul><li>身份标识</li><li>类型</li><li>值</li></ul><h3 id="身份标识"><a href="#身份标识" class="headerlink" title="身份标识"></a>身份标识</h3><p>python有一个内置函数<a href="https://docs.python.org/3/library/functions.html?highlight=id#id" target="_blank" rel="noopener">id</a></p><blockquote><p><code>id</code>(<em>object</em>)</p><p>Return the “identity” of an object. This is an integer which is guaranteed to be unique and constant for this object during its lifetime. Two objects with non-overlapping lifetimes may have the same <a href="https://docs.python.org/3/library/functions.html?highlight=id#id" target="_blank" rel="noopener"><code>id()</code></a> value.</p><p><strong>CPython implementation detail:</strong> This is the address of the object in memory.</p></blockquote><p>在一个对象的生命周期内，对它调用id函数，会得到一个唯一的值。如果两个对象的生命周期不重叠的话，那么它们的id值可能会相同。在CPython的实现细节中，id函数得到的就是这个对象在内存中的地址。</p><h3 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h3><p>调用type()可以得到对象的类型，当然type也是一个特殊的对象。</p><h3 id="值"><a href="#值" class="headerlink" title="值"></a>值</h3><p>可以理解为如何根据类型来解释这块内存区域，从而得到数据值</p><h2 id="赋值的实质"><a href="#赋值的实质" class="headerlink" title="赋值的实质"></a>赋值的实质</h2><p>在我看来，python的赋值就是名称的绑定，把一个变量名绑定到某个对象上。</p><p>对于不可变类型，在内存中只有1个备份。比如下面的例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">3</span></span><br><span class="line">b = a</span><br><span class="line">c = int(<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(d)</span>:</span></span><br><span class="line">    print(id(d))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">print(id(a), id(b), id(c))</span><br><span class="line">func(a)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1440339792 1440339792 1440339792</span><br><span class="line">1440339792</span><br></pre></td></tr></table></figure><p>这样在赋值的时候就可以不用创建新的对象，直接把新的变量名绑定到原来的对象上就行了。每当有一个新的变量指向一个对象时，它的引用计数就会加1。当引用计数变为0后，python就会回收它占用的内存。</p><h2 id="回归到问题本身"><a href="#回归到问题本身" class="headerlink" title="回归到问题本身"></a>回归到问题本身</h2><p>有的人认为，python在传递不可变类型的时候是值传递，而在传递可变类型的时候是传递引用。他们的依据是：传递不可变类型时，函数内部改变这个变量的值，不能影响函数外的值。如下面的例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">change</span><span class="params">(b)</span>:</span></span><br><span class="line">    b = <span class="number">2</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">a = <span class="number">1</span></span><br><span class="line">print(<span class="string">'before:'</span>, a)</span><br><span class="line">change(a)</span><br><span class="line">print(<span class="string">'after:'</span>, a)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">before: 1</span><br><span class="line">after: 1</span><br></pre></td></tr></table></figure><p>而在我看来，这只是从表象上来看的观点，而实质是，在调用函数<code>change</code>的时候，执行了<code>b=1</code>，这个时候变量<code>b</code>绑定到了<code>int</code>型、值为<code>1</code>的对象上，然后在函数内部的<code>b=2</code>根本没有试图去改变外面的变量<code>a</code>，它只是把变量<code>b</code>绑定到了<code>2</code>这个<code>int</code>型变量上了。</p><ul><li>参数传递之前，<code>int</code>型、值为<code>1</code>的对象的引用计数为1</li><li>参数传递之后，<code>int</code>型、值为<code>1</code>的对象的引用计数为2</li></ul><p>那为什么在函数内部可以改变可变类型呢，其实这就很好理解了，比如下面的代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">change</span><span class="params">(b)</span>:</span></span><br><span class="line">    b.append(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">a = [<span class="number">1</span>]</span><br><span class="line">print(<span class="string">'before:'</span>, a)</span><br><span class="line">change(a)</span><br><span class="line">print(<span class="string">'after:'</span>, a)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">before: [1]</span><br><span class="line">after: [1, 2]</span><br></pre></td></tr></table></figure><p>在参数传递之后，<code>b</code>和<code>a</code>指向同一个<code>list</code>对象，那么<code>b.append</code>其实是等同于<code>a.append</code>的，都是对内存中同一个对象的<code>append</code>方法的调用而已。如果在函数中执行<code>b=3</code>，也丝毫无法影响外面的变量<code>a</code>。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>所以，在我看来，python的参数传递是引用传递。参数传递前后，某个对象的引用计数增加了1。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近在看python的面试题的时候，遇到这个问题“python是值传递还是引用传递”，因此记录下我对这个问题的学习和思考。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="python" scheme="https://zenxme.github.io/tags/python/"/>
    
      <category term="面试" scheme="https://zenxme.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
</feed>
